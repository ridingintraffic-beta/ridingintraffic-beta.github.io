<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>2018-11-13 QMK-deepdive-sweeet16 | what did I learn today</title><meta name=keywords content><meta name=description content="QMK deepdive using a sweeet16 16 keys!? What can be done with 16 keys for a keyboard? Using an amazing open source firmware and a kit by 1upkeyboards, much can be done with only 16 keys. QMK is a powerhouse of a firmware that allows an endless combination of regular keys, functions and extended macros. These features are relatively easy to construct and the firmware itself can be very easy to build and flash."><meta name=author content="Mike Fettis"><link rel=canonical href=https://ridingintraffic-beta.github.io/posts/2018-11-13-qmk_deepdive_sweet16/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ridingintraffic-beta.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://ridingintraffic-beta.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ridingintraffic-beta.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ridingintraffic-beta.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://ridingintraffic-beta.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-92674236-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="2018-11-13 QMK-deepdive-sweeet16"><meta property="og:description" content="QMK deepdive using a sweeet16 16 keys!? What can be done with 16 keys for a keyboard? Using an amazing open source firmware and a kit by 1upkeyboards, much can be done with only 16 keys. QMK is a powerhouse of a firmware that allows an endless combination of regular keys, functions and extended macros. These features are relatively easy to construct and the firmware itself can be very easy to build and flash."><meta property="og:type" content="article"><meta property="og:url" content="https://ridingintraffic-beta.github.io/posts/2018-11-13-qmk_deepdive_sweet16/"><meta property="og:image" content="https://ridingintraffic-beta.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-11-13T08:08:50-04:00"><meta property="article:modified_time" content="2018-11-13T08:08:50-04:00"><meta property="og:site_name" content="what did i learn today"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ridingintraffic-beta.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="2018-11-13 QMK-deepdive-sweeet16"><meta name=twitter:description content="QMK deepdive using a sweeet16 16 keys!? What can be done with 16 keys for a keyboard? Using an amazing open source firmware and a kit by 1upkeyboards, much can be done with only 16 keys. QMK is a powerhouse of a firmware that allows an endless combination of regular keys, functions and extended macros. These features are relatively easy to construct and the firmware itself can be very easy to build and flash."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ridingintraffic-beta.github.io/posts/"},{"@type":"ListItem","position":2,"name":"2018-11-13 QMK-deepdive-sweeet16","item":"https://ridingintraffic-beta.github.io/posts/2018-11-13-qmk_deepdive_sweet16/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"2018-11-13 QMK-deepdive-sweeet16","name":"2018-11-13 QMK-deepdive-sweeet16","description":"QMK deepdive using a sweeet16 16 keys!? What can be done with 16 keys for a keyboard? Using an amazing open source firmware and a kit by 1upkeyboards, much can be done with only 16 keys. QMK is a powerhouse of a firmware that allows an endless combination of regular keys, functions and extended macros. These features are relatively easy to construct and the firmware itself can be very easy to build and flash.","keywords":[],"articleBody":"QMK deepdive using a sweeet16 16 keys!? What can be done with 16 keys for a keyboard? Using an amazing open source firmware and a kit by 1upkeyboards, much can be done with only 16 keys. QMK is a powerhouse of a firmware that allows an endless combination of regular keys, functions and extended macros. These features are relatively easy to construct and the firmware itself can be very easy to build and flash.\nFirst things first what is a sweet16? It is a macropad sold as a kit, made by 1upkeyboards. This macropad requires assembly, which includes soldering in the diodes, arduino and switches. All and all the assembly should take from 20min to an hour depending on skillset and haste. Sweet 16 Macro Pad - 1Up Keyboards\nan assembly video can be found here: youtu.be/Bw-BvKnZqBg (embedding youtube doesn’t work in medium) Truncated assembly photos are included here \u003c– The video is the best source of a step by step walkthrough assembling the pad. The goal of the article today is not to walk through the hardware assembly but more about the software.\nThe macropad has now been assembled and there is a supplied basic firmware that will give the functionality of a simple numpad. The hex file is here: sweet16.hex QMK has a great flashing program called QMK toolbox, it is available for mac and pc and can be downloaded here. qmk.fm/toolbox/ It is as easy as downloading the toolbox running the application and then plugging in the sweet16 macropad. First open the qmk toolbox app and load the hex file that was downloaded above. Then plug in the pad and there is a reset switch on the back, press that and the toolbox registers a new device, then just click flash, wait a few seconds and wait for “done”.\nafter hitting reset\nthe flash is complete The point of the simple hex firmware is to ensure that all of the switches are working properly and the assembly was successful. It can be a bit tricky to make sure all the solder points are good. Therefore, a simple keypad debug is the easiest way to confirm assembly.\nThe hardware is assembled correctly and everything works. Now on to the fun part. Building the custom firmware. The qmk docs are great for explaining everything about the firmware and the source code is, open source. Links to the firmware and docs are below. It is highly suggested, reading through all of these.\nqmk/qmk_firmware\nkeyboard controller firmware for Atmel AVR and ARM USB families - qmk/qmk_firmware github.com QMK Firmware\nDescription docs.qmk.fm Great, welcome back. The three main files that are modified when working with qmk firmware are all found in the folder of the specific keyboard. in this cases its keyboards/1upkeyboards/sweet16 The important files are config.h keymap.c rules.mk The config.h is where global variables are setup. The rules.mk is where functionally is enabled or disabled, such as turn on RGB underglow or “tap dance”. Finally the keymap.c is where the magic happens, this is the file that defines what the keys do and has the custom functions.\nThe firmware that is referenced can be found as a part of the master branch for QMK (medium doesn’t want to embed) yey! author, open source contribution ftw sweet16/keymaps/ridingintraffic/keymap.c\n... const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = { /* EMOJI Pad * ,-------------------------------. * |TFLIP | TFlIP2|DISFACE| FU | * |------+-------+-------+--------| * | CLOUD| | | CLEAR | * |------+-------+-------+--------| * |SHRUG |DISFACE| HRTFAC| HAPPYF | * |------+-------+-------+--------| * | ENTER| |LEDCNTR| tapland| * `-------------------------------' */ //purple [_EMOJI] = LAYOUT_ortho_4x4( TFLIP, TFLIP2, KC_NO, FU , CLOUD, KC_NO, KC_NO, CMDCLEAR, SHRUG, DISFACE, HEARTFACE, HAPPYFACE, KC_ENT, RGB_TOG, MO(_LEDCNTL), MO(_TAPLAND) ), ``` This first snippet is an example of the basic key layout. In the real firmware the variables initialization for all the custom keys is done at the top, but here is where the grid of keys are assigned and the “odd” names of tflip and disface are used, wat? This is the fun part, these odd keynames are actually functions that invoke sending hexcode combinations through the keyboard for that single key press which will print an inline ascii art reaction emoji. tflip: (╯°□°)╯ ︵ ┻━┻ tflip2: ┻━┻︵ \\(°□°)/ ︵ ┻━┻ fu: t(-_-t) cloud: (っ◕‿◕)っ shrug: ¯\\_(ツ)_/¯ disface: ಠ_ಠ heartface: ♥‿♥ happyface: ʘ‿ʘ These custom keycodes when pressed, trigger a function that passes the hexcodes. This is done simply below bool process_record_user(uint16_t keycode, keyrecord_t *record) { if (record-\u003eevent.pressed) { switch(keycode) { case CLOUD: // (っ◕‿◕)っ if(record-\u003eevent.pressed){ send_unicode_hex_string(“0028 3063 25D5 203F 25D5 0029 3063”); } return false; break; case FU: // t(--t) if(record-\u003eevent.pressed){ SEND_STRING(“t(--t)”); } return false; break;\ncase HAPPYFACE: // ʘ‿ʘ if(record-\u003eevent.pressed){ send_unicode_hex_string(“0298 203F 0298”); } return false; break; case CMDCLEAR: if (record-\u003eevent.pressed) { register_code(KC_LGUI); tap_code(KC_A); unregister_code(KC_LGUI); tap_code(KC_DEL); } return false; break;\ncase SHRUG: // ¯_(ツ)_/¯ if (record-\u003eevent.pressed) { send_unicode_hex_string(“00AF 005C 005F 0028 30C4 0029 005F 002F 00AF”); } return false; break; case HEARTFACE: // ♥‿♥ if(record-\u003eevent.pressed){ send_unicode_hex_string(“2665 203F 2665”); } return false; break;\ncase DISFACE: // ಠ_ಠ if(record-\u003eevent.pressed){ send_unicode_hex_string(“0CA0 005F 0CA0”); } return false; break; case TFLIP: // (╯°□°)╯ ︵ ┻━┻ if(record-\u003eevent.pressed){ send_unicode_hex_string(“0028 256F 00B0 25A1 00B0 0029 256F 0020 FE35 0020 253B 2501 253B”); } return false; break; case TFLIP2: // ┻━┻︵ (°□°)/ ︵ ┻━┻\nif(record-\u003eevent.pressed){ send_unicode_hex_string(“253B 2501 253B FE35 0020 005C 0028 00B0 25A1 00B0 0029 002F 0020 FE35 0020 253B 2501 253B”); } return false; break; } } return true; }\nSimple enough, now the macropad has simple functionality and has been filled up with reaction emojis. Some would find that useful others may see it as a waste. That is where the concept of layering comes in. Documentation of course is available explaining exactly how layering works [switching-and-toggling-layers](https://docs.qmk.fm/#/feature_advanced_keycodes?id=switching-and-toggling-layers \"switching-and-toggling-layers\") Think of layers like switching from upper case to lower case, or the symbols that are in the number row. There is the ability to toggle between layers much like capslock, however it can be easier to just have a shift key style layering called “momentary” or “mo” layering, where the layer is only active while a key is held. Either way that now enables a whole new set of functions to be added to the keys while only sacrificing a single key to switch between the layers. Onto the final chapter, “tap dance”. This is where things get a little weird. With normal keyboards and normal experiences a single keypress enters a single key, and a quicker double keypress enters two of those keys. With qmk and tapdance this all changes because when enabled and coded, the tap dance functionality will say “when pressed once” output a , when “pressed twice in 500ms” output super happy fun guy . The example is below keymap.c …. /* tap dance time */ void tdexample1(qk_tap_dance_state_t *state, void *user_data) { if (state-\u003ecount \u003e= 2) { SEND_STRING(EXAMPLESTRING1); reset_tap_dance (state); } } void tdexample2(qk_tap_dance_state_t *state, void *user_data) { if (state-\u003ecount \u003e= 2) { SEND_STRING(EXAMPLESTRING2); reset_tap_dance (state); } } void tdexample3(qk_tap_dance_state_t *state, void *user_data) { if (state-\u003ecount \u003e= 2) { SEND_STRING(EXAMPLESTRING3); reset_tap_dance (state); } } void tdexample4(qk_tap_dance_state_t *state, void *user_data) { if (state-\u003ecount \u003e= 2) { SEND_STRING(EXAMPLESTRING4); reset_tap_dance (state); } }\nqk_tap_dance_action_t tap_dance_actions[] = { [TD_EXAMPLE1] = ACTION_TAP_DANCE_FN(tdexample1), [TD_EXAMPLE2] = ACTION_TAP_DANCE_FN(tdexample2), [TD_EXAMPLE3] = ACTION_TAP_DANCE_FN(tdexample3), [TD_EXAMPLE4] = ACTION_TAP_DANCE_FN(tdexample4) };\n…\nconfig.h …\n#define EXAMPLESTRING1 “tapdance_1” #define EXAMPLESTRING2 “tapdance_2” #define EXAMPLESTRING3 “tapdance_3” #define EXAMPLESTRING4 “tapdance_4”\nHere the keycode TD_EXAMPLE1 is bound to the tapdance function tdexample1 and then that function sends the string that was defined in config.h that outputs tapdance_1 . It sounds a little complicated but break it down and then its simple, tap the key once get an emjoi, double tap the key get a whole string. Add in a layer shift and then there is an entire new functionality behind the key. And it is done The sweet16 macropad is now massively more useful than just a single numpad with 16 buttons. The macropad has enough memory to do at least 4+ layers like this. At which point it is pretty tough to keep all the functions memorized. But thats not all. QMK comes equipped with a Dockerfile. Which means building the firmware is as simple as having docker installed and then running the build process from docker. An example command would be: docker run -e keymap=ridingintraffic -e keyboard=1upkeyboards/sweet16 — rm -v $('pwd'):/qmk:rw edasque/qmk_firmware Through the power of docker it is volume mounting the working directory with all of the keyboard keymaps, into the image and then all of the build dependancies are prebuilt in the image and the Ccode is then converted into a hex file in the root folder of QMK. No muss no fuss just a clean build environment and the compiled hex files for the keyboard. Anyone that has tried to compile firmware before, knows that this is a massive time savings and the reproducibility is incredible. Thats it! A macropad and an entire open source firmware that supports over 120 keyboards. QMK and the open source community behind it are wonderful. There is a discord chat as well if chatting to a human is helpful when stuck, or let me know and I can help out wherever I can. ","wordCount":"1517","inLanguage":"en","datePublished":"2018-11-13T08:08:50-04:00","dateModified":"2018-11-13T08:08:50-04:00","author":{"@type":"Person","name":"Mike Fettis"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ridingintraffic-beta.github.io/posts/2018-11-13-qmk_deepdive_sweet16/"},"publisher":{"@type":"Organization","name":"what did I learn today","logo":{"@type":"ImageObject","url":"https://ridingintraffic-beta.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ridingintraffic-beta.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ridingintraffic-beta.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ridingintraffic-beta.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ridingintraffic-beta.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://ridingintraffic.github.io title=traffic><span>traffic</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ridingintraffic-beta.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ridingintraffic-beta.github.io/posts/>Posts</a></div><h1 class=post-title>2018-11-13 QMK-deepdive-sweeet16</h1><div class=post-meta><span title='2018-11-13 08:08:50 -0400 -0400'>2018-11-13</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1517 words&nbsp;·&nbsp;Mike Fettis&nbsp;|&nbsp;<a href=https://github.com/ridingintraffic-beta/ridingintraffic-beta.github.io/blob/main/content/posts/2018-11-13-qmk_deepdive_sweet16.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=qmk-deepdive-using-a-sweeet16>QMK deepdive using a sweeet16<a hidden class=anchor aria-hidden=true href=#qmk-deepdive-using-a-sweeet16>#</a></h1><p>16 keys!? What can be done with 16 keys for a keyboard? Using an amazing open source firmware and a kit by 1upkeyboards, much can be done with only 16 keys. QMK is a powerhouse of a firmware that allows an endless combination of regular keys, functions and extended macros. These features are relatively easy to construct and the firmware itself can be very easy to build and flash.</p><p>First things first what is a sweet16? It is a macropad sold as a kit, made by 1upkeyboards. This macropad requires assembly, which includes soldering in the diodes, arduino and switches. All and all the assembly should take from 20min to an hour depending on skillset and haste.
<a href=https://www.1upkeyboards.com/shop/keyboard-kits/sweet16-macro-pad-white/ title="Sweet 16 Macro Pad - 1Up Keyboards">Sweet 16 Macro Pad - 1Up Keyboards</a></p><p>an assembly video can be found here: <a href=https://youtu.be/Bw-BvKnZqBg title=youtu.be/Bw-BvKnZqBg>youtu.be/Bw-BvKnZqBg</a>
(embedding youtube doesn&rsquo;t work in medium) Truncated assembly photos are included here &lt;&ndash;
The video is the best source of a step by step walkthrough assembling the pad. The goal of the article today is not to walk through the hardware assembly but more about the software.</p><p>The macropad has now been assembled and there is a supplied basic firmware that will give the functionality of a simple numpad. The hex file is here: <a href=https://1upkeyboards.com/sweet16.hex title="sweet16.hex ">sweet16.hex</a> QMK has a great flashing program called QMK toolbox, it is available for mac and pc and can be downloaded here. <a href=https://qmk.fm/toolbox/ title=qmk.fm/toolbox/>qmk.fm/toolbox/</a> It is as easy as downloading the toolbox running the application and then plugging in the sweet16 macropad. First open the qmk toolbox app and load the hex file that was downloaded above. Then plug in the pad and there is a reset switch on the back, press that and the toolbox registers a new device, then just click flash, wait a few seconds and wait for “done”.</p><p>after hitting reset</p><p>the flash is complete
The point of the simple hex firmware is to ensure that all of the switches are working properly and the assembly was successful. It can be a bit tricky to make sure all the solder points are good. Therefore, a simple keypad debug is the easiest way to confirm assembly.</p><p>The hardware is assembled correctly and everything works. Now on to the fun part. Building the custom firmware. The qmk docs are great for explaining everything about the firmware and the source code is, open source. Links to the firmware and docs are below. It is highly suggested, reading through all of these.</p><p>qmk/qmk_firmware</p><p>keyboard controller firmware for Atmel AVR and ARM USB families - qmk/qmk_firmware
github.com
QMK Firmware</p><p>Description
docs.qmk.fm
Great, welcome back. The three main files that are modified when working with qmk firmware are all found in the folder of the specific keyboard. in this cases its keyboards/1upkeyboards/sweet16 The important files are config.h keymap.c rules.mk The config.h is where global variables are setup. The rules.mk is where functionally is enabled or disabled, such as turn on RGB underglow or “tap dance”. Finally the keymap.c is where the magic happens, this is the file that defines what the keys do and has the custom functions.</p><p>The firmware that is referenced can be found as a part of the master branch for QMK (medium doesn&rsquo;t want to embed) yey! author, open source contribution ftw <a href=https://raw.githubusercontent.com/qmk/qmk_firmware/master/keyboards/1upkeyboards/sweet16/keymaps/ridingintraffic/keymap.c title=sweet16/keymaps/ridingintraffic/keymap.c>sweet16/keymaps/ridingintraffic/keymap.c</a></p><pre tabindex=0><code>...

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {

    /* EMOJI Pad
    * ,-------------------------------.
    * |TFLIP | TFlIP2|DISFACE|   FU   |
    * |------+-------+-------+--------|
    * | CLOUD|       |       | CLEAR  |
    * |------+-------+-------+--------|
    * |SHRUG |DISFACE| HRTFAC| HAPPYF |
    * |------+-------+-------+--------|
    * | ENTER|       |LEDCNTR| tapland| 
    * `-------------------------------&#39;
    */
      //purple
    [_EMOJI] = LAYOUT_ortho_4x4(
       TFLIP,   TFLIP2,   KC_NO,      FU , 
       CLOUD,   KC_NO,  KC_NO,      CMDCLEAR, 
       SHRUG,   DISFACE,  HEARTFACE,    HAPPYFACE, 
       KC_ENT,  RGB_TOG,  MO(_LEDCNTL), MO(_TAPLAND)
    ),
    ```

This first snippet is an example of the basic key layout. In the real firmware the variables initialization for all the custom keys is done at the top, but here is where the grid of keys are assigned and the “odd” names of tflip and disface are used, wat? This is the fun part, these odd keynames are actually functions that invoke sending hexcode combinations through the keyboard for that single key press which will print an inline ascii art reaction emoji.

tflip: (╯°□°)╯ ︵ ┻━┻
tflip2: ┻━┻︵ \(°□°)/ ︵ ┻━┻
fu: t(-_-t)
cloud: (っ◕‿◕)っ
shrug: ¯\_(ツ)_/¯
disface: ಠ_ಠ
heartface: ♥‿♥
happyface: ʘ‿ʘ
These custom keycodes when pressed, trigger a function that passes the hexcodes. This is done simply below
</code></pre><p>bool process_record_user(uint16_t keycode, keyrecord_t *record) {
if (record->event.pressed) {
switch(keycode) {
case CLOUD: // (っ◕‿◕)っ
if(record->event.pressed){
send_unicode_hex_string(&ldquo;0028 3063 25D5 203F 25D5 0029 3063&rdquo;);
}
return false;
break;
case FU: // t(-<em>-t)
if(record->event.pressed){
SEND_STRING(&ldquo;t(-</em>-t)&rdquo;);
}
return false;
break;<br>case HAPPYFACE: // ʘ‿ʘ
if(record->event.pressed){
send_unicode_hex_string(&ldquo;0298 203F 0298&rdquo;);
}
return false;
break;
case CMDCLEAR:
if (record->event.pressed) {
register_code(KC_LGUI);
tap_code(KC_A);<br>unregister_code(KC_LGUI);
tap_code(KC_DEL);<br>}
return false;
break;<br>case SHRUG: // ¯_(ツ)_/¯
if (record->event.pressed) {
send_unicode_hex_string(&ldquo;00AF 005C 005F 0028 30C4 0029 005F 002F 00AF&rdquo;);
}
return false;
break;
case HEARTFACE: // ♥‿♥
if(record->event.pressed){
send_unicode_hex_string(&ldquo;2665 203F 2665&rdquo;);
}
return false;
break;<br>case DISFACE: // ಠ_ಠ
if(record->event.pressed){
send_unicode_hex_string(&ldquo;0CA0 005F 0CA0&rdquo;);
}
return false;
break;
case TFLIP: // (╯°□°)╯ ︵ ┻━┻
if(record->event.pressed){
send_unicode_hex_string(&ldquo;0028 256F 00B0 25A1 00B0 0029 256F 0020 FE35 0020 253B 2501 253B&rdquo;);
}
return false;
break;
case TFLIP2: // ┻━┻︵ (°□°)/ ︵ ┻━┻<br>if(record->event.pressed){
send_unicode_hex_string(&ldquo;253B 2501 253B FE35 0020 005C 0028 00B0 25A1 00B0 0029 002F 0020 FE35 0020 253B 2501 253B&rdquo;);
}
return false;
break;
}
}
return true;
}</p><pre tabindex=0><code>

Simple enough, now the macropad has simple functionality and has been filled up with reaction emojis. Some would find that useful others may see it as a waste. That is where the concept of layering comes in. Documentation of course is available explaining exactly how layering works [switching-and-toggling-layers](https://docs.qmk.fm/#/feature_advanced_keycodes?id=switching-and-toggling-layers &#34;switching-and-toggling-layers&#34;) Think of layers like switching from upper case to lower case, or the symbols that are in the number row. There is the ability to toggle between layers much like capslock, however it can be easier to just have a shift key style layering called “momentary” or “mo” layering, where the layer is only active while a key is held. Either way that now enables a whole new set of functions to be added to the keys while only sacrificing a single key to switch between the layers.

Onto the final chapter, “tap dance”. This is where things get a little weird. With normal keyboards and normal experiences a single keypress enters a single key, and a quicker double keypress enters two of those keys. With qmk and tapdance this all changes because when enabled and coded, the tap dance functionality will say “when pressed once” output a , when “pressed twice in 500ms” output super happy fun guy . The example is below
</code></pre><p>keymap.c
&mldr;.
/* tap dance time */
void tdexample1(qk_tap_dance_state_t *state, void *user_data) {
if (state->count >= 2) {
SEND_STRING(EXAMPLESTRING1);
reset_tap_dance (state);
}
}
void tdexample2(qk_tap_dance_state_t *state, void *user_data) {
if (state->count >= 2) {
SEND_STRING(EXAMPLESTRING2);
reset_tap_dance (state);
}
}
void tdexample3(qk_tap_dance_state_t *state, void *user_data) {
if (state->count >= 2) {
SEND_STRING(EXAMPLESTRING3);
reset_tap_dance (state);
}
}
void tdexample4(qk_tap_dance_state_t *state, void *user_data) {
if (state->count >= 2) {
SEND_STRING(EXAMPLESTRING4);
reset_tap_dance (state);
}
}</p><p>qk_tap_dance_action_t tap_dance_actions[] = {
[TD_EXAMPLE1] = ACTION_TAP_DANCE_FN(tdexample1),
[TD_EXAMPLE2] = ACTION_TAP_DANCE_FN(tdexample2),
[TD_EXAMPLE3] = ACTION_TAP_DANCE_FN(tdexample3),
[TD_EXAMPLE4] = ACTION_TAP_DANCE_FN(tdexample4)
};</p><p>&mldr;</p><p>config.h
&mldr;</p><p>#define EXAMPLESTRING1 &ldquo;tapdance_1&rdquo;
#define EXAMPLESTRING2 &ldquo;tapdance_2&rdquo;
#define EXAMPLESTRING3 &ldquo;tapdance_3&rdquo;
#define EXAMPLESTRING4 &ldquo;tapdance_4&rdquo;</p><pre tabindex=0><code>
Here the keycode TD_EXAMPLE1 is bound to the tapdance function tdexample1 and then that function sends the string that was defined in config.h that outputs tapdance_1 . It sounds a little complicated but break it down and then its simple, tap the key once get an emjoi, double tap the key get a whole string. Add in a layer shift and then there is an entire new functionality behind the key. And it is done The sweet16 macropad is now massively more useful than just a single numpad with 16 buttons. The macropad has enough memory to do at least 4+ layers like this. At which point it is pretty tough to keep all the functions memorized.

But thats not all. QMK comes equipped with a Dockerfile. Which means building the firmware is as simple as having docker installed and then running the build process from docker. An example command would be: docker run -e keymap=ridingintraffic -e keyboard=1upkeyboards/sweet16 — rm -v $(&#39;pwd&#39;):/qmk:rw edasque/qmk_firmware Through the power of docker it is volume mounting the working directory with all of the keyboard keymaps, into the image and then all of the build dependancies are prebuilt in the image and the Ccode is then converted into a hex file in the root folder of QMK. No muss no fuss just a clean build environment and the compiled hex files for the keyboard. Anyone that has tried to compile firmware before, knows that this is a massive time savings and the reproducibility is incredible.

Thats it! A macropad and an entire open source firmware that supports over 120 keyboards. QMK and the open source community behind it are wonderful. There is a discord chat as well if chatting to a human is helpful when stuck, or let me know and I can help out wherever I can.
</code></pre></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ridingintraffic-beta.github.io/posts/2018-11-13-mechanical_and_custom_keyboards/><span class=title>« Prev</span><br><span>2018-11-13 Mechanical_and_custom_keyboards</span></a>
<a class=next href=https://ridingintraffic-beta.github.io/posts/2018-11-12-docker_powershell/><span class=title>Next »</span><br><span>2018-11-12 docker-powershell</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 2018-11-13 QMK-deepdive-sweeet16 on twitter" href="https://twitter.com/intent/tweet/?text=2018-11-13%20QMK-deepdive-sweeet16&url=https%3a%2f%2fridingintraffic-beta.github.io%2fposts%2f2018-11-13-qmk_deepdive_sweet16%2f&hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 2018-11-13 QMK-deepdive-sweeet16 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fridingintraffic-beta.github.io%2fposts%2f2018-11-13-qmk_deepdive_sweet16%2f&title=2018-11-13%20QMK-deepdive-sweeet16&summary=2018-11-13%20QMK-deepdive-sweeet16&source=https%3a%2f%2fridingintraffic-beta.github.io%2fposts%2f2018-11-13-qmk_deepdive_sweet16%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 2018-11-13 QMK-deepdive-sweeet16 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fridingintraffic-beta.github.io%2fposts%2f2018-11-13-qmk_deepdive_sweet16%2f&title=2018-11-13%20QMK-deepdive-sweeet16"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 2018-11-13 QMK-deepdive-sweeet16 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fridingintraffic-beta.github.io%2fposts%2f2018-11-13-qmk_deepdive_sweet16%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 2018-11-13 QMK-deepdive-sweeet16 on whatsapp" href="https://api.whatsapp.com/send?text=2018-11-13%20QMK-deepdive-sweeet16%20-%20https%3a%2f%2fridingintraffic-beta.github.io%2fposts%2f2018-11-13-qmk_deepdive_sweet16%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 2018-11-13 QMK-deepdive-sweeet16 on telegram" href="https://telegram.me/share/url?text=2018-11-13%20QMK-deepdive-sweeet16&url=https%3a%2f%2fridingintraffic-beta.github.io%2fposts%2f2018-11-13-qmk_deepdive_sweet16%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://ridingintraffic-beta.github.io/>what did I learn today</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>